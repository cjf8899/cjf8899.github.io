---
title:  "AdaIN paper review"
last_modified_at: 2021-01-01 00:00:00 -0400
categories: 
  - Generative Adversarial Network
tags:
  - update
toc: true
toc_label: "Getting Started"
---

# AdaIN
> Xun Huang, et al. ["Arbitrary Style Transfer in Real-time with Adaptive Instance Normalization."](https://arxiv.org/abs/1703.06868) Proceedings of the IEEE International Conference on Computer Vision (ICCV)2017.

# AdaIN 리뷰

안녕하세요. **AiRLab**(한밭대학교 인공지능 및 로보틱스 연구실) 노현철 입니다. 
제가 이번에 리뷰할 논문은 **"Arbitrary Style Transfer in Real-time with Adaptive Instance Normalization"** 입니다.

# Abstract
-콘텐츠 이미지를 다른 이미지 스타일로 렌터링하는 알고리즘 도입<br>
-하지만 프레임워크에서는 느린 프레임워크에서 최적화 되어 실제 적용이 제한된다.<br>
-신경 스타일 전송속도를 높이기 위해 feed-forward neural networks가 제안되었다. 하지만 속도향상의 따른 대가는 고정된 스타일만 적용가능하고 새로운 스타일은 적용 불가능이다.<br>
-이 논문은 새로운 스타일에 대해서도 실시간으로 전송할 수 있고, 간단하면서도 효과적인 접근방식을 제시한다.<br>
-우리의 핵심방식은 콘텐츠의 특징의 평균, 분산을 새로운 스타일의 평균, 분산으로 정렬하는 novel adaptive instance normalization (AdaIN) 이다.<br>
-스타일의 제한없이 가장 빠른 속도를 가진다.<br>
-또한, 우리는 content-style trade-off, style interpolation, color & spatial controls와 같은 사용자 제어를 허용한다.<br>

<img src="https://user-images.githubusercontent.com/53032349/98468155-845c4400-221c-11eb-918e-201343d0023d.jpg" width="50%" height="50%" title="70px" alt="memoryblock">

# Introduction
-DNN은 콘텐츠와 이미지 스타일 정보도 인코딩을 한다. 또한 둘을 분리할 수 있다. 콘텐츠를 유지하면서 스타일 변경이 가능하다. 그러나 매우 느리다.<br>
-스타일 전송을 가속화하기 위해 많은 노력을 기울였다.<br>
-이 문제를 다루는 논문은 유한한 스타일 세트로 제한되거나 단일 스타일(새로운 스타일) 전송은 훨씬 느리다.<br>
-우리의 작업은 이러한 근본적인 유연성, 속도를 해결하는 알고리즘을 제시한다.<br>
-우리의 알고리즘은 가장 빠른 feed-forward와 유사하며, 새로운 스타일을 real-time으로 전송할 수 있다.<br>
-우리의 메소드는 instance normalization에서 영감을 받았으며, feed-forward에서 놀라운 효과를 얻었다<br>
-instance normalization는 이미지의 스타일 정보를 전달하는 것으로 밝혀진 특성 통계를 정규화하여 스타일 정규화를 수행한다는 새로운 해석을 제안하였다(다른 논문에서)<br>
-이러한 해석을 동기화 하여 간단한 확장, adaptive instance normalization (AdaIN)를 소개한다.<br>
-콘텐츠(input image)와 스타일이 주워지면 AdaIN은 단순히 스타일의 입력과 일치하도록 콘텐츠의 평균, 분산을 조정한다.<br>
-실험을 통해 AdaIN은 기능 통계를 전송하여 콘텐츠 전자, 스타일 후자를 효과적으로 결합한다. 이후 AdaIN 출력을 이미지 공간으로 반전하여 최종 이미지를 생성한다.<br>
-우리의 방법은 기존 방식(DNN) 보다 3배 빠르고, 프로세서를 수정하지 않고도 사용제 제어가 가능하다.<br>


# Related Work
-스타일 전송은 다양한 방법들이 있고, 대부분 시간을 소비하는 대신 비디오 스타일의 품질을 향상시켰다.<br>
-느린 최적화 속도로 인해 최신GPU를 사용하더라도 느리다. 따라서 모바일 애플리케이션으로는 실용적이지 못 하다.<br>
-해결방법으로는 f최소한으로 훈련된 feed-forward신경망으로 대체하였고, 약 3배 빠르게 real-time 애플리이케이션으로 최적화하였다. 또한 여러 가지 방법들로 인해 새로운 스타일을 전송할 수 있는 아키텍쳐들이 제안되었지만, 새로운 스타일에 대해서는 적응할 수 없었다<br>었다.
-가장 최근 새로운 스타일 전송방식이 나왔지만(가장 일치하는 스타일로 적용) 병목현상을 발생 시킨다. <br>
-우리의 접근방식은 이와 같이 새로운 스타일 전송 하지만 1-2배 빠르다.<br>
-스타일 전송의 다른 핵심 문제는 스타일 손실 함수이다.<br>
-MRF loss, adversarial loss, histogram loss, CORAL loss, MMD loss, and distance between channel-wise mean and variance를 사용하는 목표는 스타일 이미지와 합성 이미지의 일부기능 통계를 일치 시키는 것<br>
-심층 모델링으로는 GAN의 프레임 워크에 대한 다양한 개선이 제안되었다.<br>

# Background
## Batch Normalization
-Faster R-CNN에는 각 후보 객체에 대해 두 개의 outputs, class label, bounding-box offset이 있는데 여기에 object mask를 출력하는 CNN(FCN) 추가. 직관적인 아이디어다.<br>
-또한, 미세한 공간 출력을 위해 핵심요소를 소개 할 것이다.<br>
-공식적으로 train에서는 multi-task loss를 사용한다. L = L_cls + L_box + L_mask<br>
-Ground-Truth에서 클래스 k와 관련된 RoI의 경우 Lmask는 k 번째 마스크에서만 정의. (다른 마스크 출력은 loss에 기여하지 않음). = RoI에서 찾은 클래스를 바탕으로 마스크를 채택, 다른 마스크는 신경 안쓴다는 말<br>
-네트워크는 경쟁없이 모든 클래스의 대한 마스크를 생성 할 수 있다. classification하여 라벨을 예측하고 라벨에 대한 마스크를 선택하는 방식이다.<br>

# Mask Representation
-FCN을 사용하여 각 RoI에서 m × m 마스크를 예측한다. <br>
-fc레이어를 사용했던 이전과 달리m × m을 유지 하면서도 더 적은 parameters, 더 좋은 성능을 가져왔다.<br>
-이러한 pixel-to-pixel으로 공간에 대한 대응을 충실하게 유지하기 위해 잘 정렬해야 한다.(=RoI가 기능이 좋아야 한다.)<br>

# RoIAlign
<img src="https://user-images.githubusercontent.com/53032349/98468511-203a7f80-221e-11eb-8a1f-e012d5fee439.png" width="80%" height="80%" title="70px" alt="memoryblock">
<img src="https://user-images.githubusercontent.com/53032349/98468518-2d576e80-221e-11eb-8d5a-31a72e6f12d2.png" width="80%" height="80%" title="70px" alt="memoryblock">
<img src="https://user-images.githubusercontent.com/53032349/98468532-39433080-221e-11eb-96c4-ba137705af9c.png" width="80%" height="80%" title="70px" alt="memoryblock">

-RoIPool은 단순히 양자화 하는 것. 소수가 나오면 반올림하여 계산.<br>
-하지만 이러한 계산은 정렬이 불량하다.(=RoI가 안 좋다.) 이로인해 성능에 대한 부정적인 영향이 끼친다.
<img src="https://user-images.githubusercontent.com/53032349/98468571-6a236580-221e-11eb-963a-8d654a8bbc8a.png" width="80%" height="80%" title="70px" alt="memoryblock">
<img src="https://user-images.githubusercontent.com/53032349/98468586-727ba080-221e-11eb-9cfe-57a929adecf6.png" width="80%" height="80%" title="70px" alt="memoryblock">

-이를 해결하기 위해 양자화가 아닌 RoIAlign을 제안. RoI경계의 양자화를 피하고 bilinear interpolation(이중선형보간)을 통해 소수점까지 계산하여 정확한 결과를 얻는다.<br>
-RoIAlign은 크게 성능을 크게 개선하였다.
<img src="https://user-images.githubusercontent.com/53032349/98468605-8fb06f00-221e-11eb-8a1b-0cf380984ff9.png" width="80%" height="80%" title="70px" alt="memoryblock">

# Network Architecture
-Mask R-CNN은 여러 아키텍쳐를 합친 네트워크이고 두 가지로 나눈다.<br>
1) convolutional backbone architecture used for feature extraction over an entire image<br>
2) the network head for bounding-box recognition (classification and regression) and mask prediction that is applied separately to each RoI

<img src="https://user-images.githubusercontent.com/53032349/98469173-604f3180-2221-11eb-96f7-7254a993f3ec.png" width="80%" height="80%" title="70px" alt="memoryblock">


-네트워크 깊이에 따른 백본 아키텍쳐로는 ResNet 및 ResNeXt 깊이 50 또는 101가 사용되었다.

# Implementation Details
* image-centric training
* Images are resized(800 pixels)
* GPU 1개당 2
* learning rate of 0.02
* 160k iterations, 120k iteration에서 Lr 10배 감소
* weight decay of 0.0001
* momentum of 0.9
* ResNeXt 사용할때는 starting learning rate of 0.01

# Experiments: Instance Segmentation
![initial](https://user-images.githubusercontent.com/53032349/98469260-c1770500-2221-11eb-8662-bbd291844bb5.png)
-AP 옆에 있는 숫자는 IoU의 수치이다. S, M, L는 객체의 크기이다.
![initial](https://user-images.githubusercontent.com/53032349/98469227-98ef0b00-2221-11eb-8f77-33aa6649dcf4.png)
![initial](https://user-images.githubusercontent.com/53032349/98469268-cc319a00-2221-11eb-9588-2a3543e04f4c.png)

-사람의 키포인트 찾는 챌린지에서도 우수한 성능을 보임
![initial](https://user-images.githubusercontent.com/53032349/98469299-fc793880-2221-11eb-9c27-944dd872bc34.png)
<img src="https://user-images.githubusercontent.com/53032349/98469303-fe42fc00-2221-11eb-9313-5d4cc7eb40b3.png" width="80%" height="80%" title="70px" alt="memoryblock">
